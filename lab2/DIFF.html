<?xml version='1.0' encoding='UTF-8' ?><!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.1//EN' 'http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd'><html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en'><head><title>Pretty Diff - The difference tool</title><meta name='robots' content='index, follow'/> <meta name='DC.title' content='Pretty Diff - The difference tool'/> <link rel='canonical' href='http://prettydiff.com/' type='application/xhtml+xml'/><meta http-equiv='Content-Type' content='application/xhtml+xml;charset=UTF-8'/><meta http-equiv='Content-Style-Type' content='text/css'/><style type='text/css'>body{font-family:'Arial';font-size:10px;overflow-y:scroll}#announcement.big{color:#00c;font-weight:bold;height:auto;left:14em;margin:0;overflow:hidden;position:absolute;text-overflow:ellipsis;top:4.5em;white-space:nowrap;width:50%;z-index:5}#announcement.big strong.duplicate{display:block}#announcement.big span{display:block}#announcement.normal{color:#000;font-weight:normal;height:2.5em;margin:0 -5em -4.75em;position:static;width:27.5em}#apireturn textarea{font-size:1.2em;height:50em;width:100%}#apitest input,#apitest label,#apitest select,#apitest textarea{float:left}#apitest input,#apitest select,#apitest textarea{width:30em}#apitest label{width:20em}#apitest p{clear:both;padding-top:0.75em}#beau-other-span,#diff-other-span{left:-20em;position:absolute;width:0}#beauops p strong,#options p strong,#diffops p strong,#miniops p strong,#options .label,#diffops .label,#miniops .label,#beauops .label{display:block;float:left;font-size:1.2em;font-weight:bold;margin-bottom:1em;width:17.5em}#beauops span strong,#miniops span strong,#diffops span strong{display:inline;float:none;font-size:1em;width:auto}#feedreport{right:38.8em}#beautyinput,#minifyinput,#baseText,#newText,#beautyoutput,#minifyoutput{font-size:1em}#Beautify,#Minify,#diffBase,#diffNew{border-radius:0.4em;padding:1em 1.25em 0}#Beautify .input,#Minify .input,#Beautify .output,#Minify .output{width:49%}#Beautify .input label,#Beautify .output label,#Minify .input label,#Minify .output label{display:block;font-size:1.05em;font-weight:bold}#Beautify p.file,#Minify p.file{clear:none;float:none}#Beautify textarea,#Minify textarea{margin-bottom:0.75em}#checklist_option li{font-weight:bold}#checklist_option li li{font-weight:normal}#codeInput{margin-bottom:1em;margin-top:-3.5em}#codeInput #diffBase p,#codeInput #diffNew p{clear:both;float:none}#codeInput .input{clear:none;float:left}#codeInput .output{clear:none;float:right;margin-top:-2.4em}#cssreport.doc table{position:absolute}#css-size{left:24em}#css-uri{left:40em}#css-uri td{text-align:left}#csvchar{width:11.8em}#dcolorScheme{float:right;margin:-2em 0 0}#dcolorScheme label{display:inline-block;font-size:1em}#diff .addsource{cursor:pointer;margin-bottom:1em;padding:0}#diff .addsource input{display:block;float:left;margin:0.5em 0.5em -1.5em}#diff .addsource label{cursor:pointer;display:inline-block;font-size:1.2em;padding:0.5em 0.5em 0.5em 2em}#diffBase,#diffNew,#Beautify,#Minify,#doc div,#doc div div,#doc ol,#option_comment,#update,#thirdparties img,#diffoutput #thirdparties,.box h3.heading,.box .body,.options,.diff .replace em,.diff .delete em,.diff .insert em,button,fieldset{border-style:solid;border-width:0.1em}#diffBase,#diffNew{padding:1.25em 1%;width:47%}#diffBase textarea,#diffNew textarea{width:99.5%}#diffBase{float:left;margin-right:1%}#diffNew{float:right}#diffoutput{width:100%}#diffoutput #thirdparties li{display:inline-block;list-style-type:none}#diffoutput li em,#diffoutput p em,.analysis .bad,.analysis .good{font-weight:bold}#diffoutput ul{font-size:1.2em;margin-top:1em}#diffoutput ul li{display:list-item;list-style-type:disc}#displayOps{float:right;font-size:1.5em;font-weight:bold;margin:0 1em 0 0;position:relative;width:22.5em;z-index:10}#displayOps #displayOps-hide{clear:both;float:none;position:absolute;top:-20em}#displayOps.default{position:static}#displayOps.maximized{margin-bottom:-2em;position:relative}#displayOps a{border-style:solid;border-width:0.1em;height:1.2em;line-height:1.4;margin:0.1em 0 0 5em;padding:0.05em 0 0.3em;text-align:center;text-decoration:none}#displayOps button,#displayOps a{font-size:1em}#displayOps li{clear:none;display:block;float:left;list-style:none;margin:0;text-align:right;width:9em}#doc_contents a{text-decoration:none}#doc_contents ol{padding-bottom:1em}#doc_contents ol ol li{font-size:0.75em;list-style:lower-alpha;margin:0.5em 0 1em 3em}#doc #doc_contents ol ol{background-color:inherit;border-style:none;margin:0.25em 0.3em 0 0;padding-bottom:0}#doc div.beautify{border-style:none}#doc #execution h3{background:transparent;border-style:none;font-size:1em;font-weight:bold}#doc code,.doc code{display:block;font-family:'Courier New',Courier,'Lucida Console',monospace;font-size:1.1em}#doc div,.doc div{margin-bottom:2em;padding:0 0.5em 0.5em}#doc div div,.doc div div{clear:both;margin-bottom:1em}#doc em,.doc em,.box .body em{font-style:normal;font-weight:bold}#doc h2,.doc h2{font-size:1.6em;margin:0.5em 0.5em 0.5em 0}#doc h3,.doc h3{margin-top:0.5em}#doc ol,.doc ol{clear:both;padding:0}#doc ol li span,.doc ol li span{display:block;margin-left:2em}#doc ol ol,#doc ul ol,.doc ol ol,.doc ul ol{margin-right:0.5em}#doc td span,.doc td span{display:block}#doc table,.doc table,.box .body table{border-collapse:collapse;border-style:solid;border-width:0.2em;clear:both}#doc table,.doc table{font-size:1.2em}#doc td,#doc th,.doc td,.doc th{border-left-style:solid;border-left-width:0.1em;border-top-style:solid;border-top-width:0.1em;padding:0.5em}#doc th,.doc th{font-weight:bold}#doc ul,.doc ul{margin-top:1em}#doc ul li,.doc ul li{font-size:1.2em}#feedemail{display:block;width:100%}#feedreportbody{text-align:center}#feedreportbody .radiogroup .feedlabel{display:block;margin:0 0 1em;width:auto;font-size:1.4em}#feedreportbody .radiogroup span{margin:0 0 2em;display:inline-block;width:5em}#feedreportbody .radiogroup input{position:absolute;top:-2000em}#feedreportbody .radiogroup label{display:inline-block;border-style:solid;border-width:0.1em;line-height:1.5;text-align:center;height:1.5em;width:1.5em;border-radius:50%;cursor:pointer}#feedreportbody .radiogroup span span{font-size:0.8em;display:block;margin:0;width:auto}#feedsubmit{position:static;width:50%;float:none;text-shadow:none;height:3em;margin:2.5em auto 0;font-family:inherit}#function_properties h4{font-size:1.2em;float:none}#function_properties h4 strong{color:#c00}#function_properties h5{margin:0 0 0 -2.5em;font-size:1em}#function_properties ol{padding-right:1em}#functionGroup.append{border-radius:0.2em;border-style:solid;border-width:0.1em;padding:0.7em 1.2em;position:relative;top:-2.625em}#functionGroup.append input{cursor:pointer}#functionGroup.append label{cursor:pointer;font-size:1em}#functionGroup.append span{display:inline-block;margin-left:2em}#hideOptions{margin-left:5em}#introduction{clear:both;margin:0 0 0 5.6em;position:relative;top:-2.75em}#introduction .information,#webtool #introduction h2{left:-90em;position:absolute;top:0;width:10em}#introduction h2{float:none}#introduction li{clear:none;display:block;float:left;font-size:1.4em;margin:0 4.95em -1em 0}#introduction li li{font-size:1em;margin-left:2em}#introduction ul{clear:both;height:3em;margin:0 0 0 -5.5em;overflow:hidden;width:100em}#modalSave p{background:#eee;color:#333;font-size:3em;padding:1em;position:absolute;text-align:center;top:10em;width:25em;z-index:9001}#modalSave p em{display:block;font-size:0.75em;margin-top:1em}#modalSave p strong{color:#c00;font-weight:bold}#modalSave span{background:#000;display:block;left:0;opacity:0.5;position:absolute;top:0;z-index:9000}#codereport{right:19.8em}#option_comment{font-size:1.2em;height:2.5em;margin-bottom:-1.5em;width:100%}#option_commentClear{float:right;height:2em;margin:-0.5em -0.25em 0 0;padding:0;width:15em}#options{margin:0 0 1em}#options label{width:auto}#options p,#addOptions p{clear:both;font-size:1em;margin:0;padding:1em 0 0}#options p span{height:2em;margin:0 0 0 1em}#pdsamples{list-style-position:inside;margin:0;padding:0;position:relative;z-index:10}#pdsamples li{border-radius:1em;border-style:solid;border-width:0.1em;margin:0 0 3em;padding:1em}#pdsamples li div{border-radius:1em;border-style:solid;border-width:0.1em;margin:0;padding:1em}#pdsamples li p{display:inline-block;font-size:1em;margin:0}#pdsamples li p a{display:block;margin:0 0 1em 2em}#pdsamples li ul{margin:0 0 0 2em}#reports{height:4em}#reports h2{display:none}#samples #dcolorScheme{position:relative;z-index:1000}#samples #pdsamples li li{background:none transparent;border-style:none;display:list-item;list-style:disc outside;margin:0;padding:0.5em}#samples h1{float:none}#samples h2{float:none;font-size:1.5em;border-style:none;margin:1em 0}#showOptionsCallOut{background:#fff;border:0.1em solid #000;box-shadow:0.2em 0.2em 0.4em rgba(0,0,0,.15);left:28.6%;padding:0.5em;position:absolute;top:4.6em;width:20%;z-index:1000}#showOptionsCallOut a{color:#66f;font-weight:bold}#showOptionsCallOut em{color:#c00}#showOptionsCallOut strong{color:#090}#statreport{right:0.8em}#statreport .body p,#statreport .body li,#statreport .body h3{font-size:1.2em}#statreport .body h3{margin-top:0}#statreport .body ul{margin-top:1em}#textareaTabKey{position:absolute;border-width:0.1em;border-style:solid;padding:0.5em;width:24em;right:51%}#textareaTabKey strong{text-decoration:underline}#textreport{width:100%}#thirdparties a{border-style:none;display:block;height:4em;text-decoration:none}#title_text{border-style:solid;border-width:0.05em;display:block;float:left;font-size:1em;margin-left:0.55em;padding:0.1em}#top{left:0;overflow:scroll;position:absolute;top:-200em;width:1em}#top em{font-weight:bold}#update{clear:left;float:right;font-weight:bold;padding:0.5em;position:absolute;right:1.25em;top:4.75em}#webtool .diff h3{border-style:none solid solid;border-width:0 0.1em 0.2em;box-shadow:none;display:block;font-family:Verdana;margin:0 0 0 -.1em;padding:0.2em 2em;text-align:left}#webtool .options input[type=text]{margin-right:1em;width:11.6em}#webtool .options input[type=text],div input,textarea{border-style:inset;border-width:0.1em}.analysis th{text-align:left}.analysis td{text-align:right}.beautify,.diff{border-style:solid;border-width:0.2em;display:inline-block;font-family:'Courier New',Courier,'Lucida Console',monospace;margin:0 1em 1em 0;position:relative}.beautify .count,.diff .count{border-style:solid;border-width:0 0.1em 0 0;font-weight:normal;padding:0;text-align:right}.beautify .count li,.diff .count li{padding-left:2em}.beautify .count li{padding-top:0.5em}.beautify .count li.fold,.diff .count li.fold{color:#900;cursor:pointer;font-weight:bold;padding-left:0.5em}.beautify .data,.diff .data{text-align:left;white-space:pre}.beautify .data em{display:inline-block;font-style:normal;font-weight:bold;padding-top:0.5em}.beautify .data li,.diff .data li{padding-left:0.5em;white-space:pre}.beautify li,.diff li{border-style:none none solid;border-width:0 0 0.1em;display:block;line-height:1.2;list-style-type:none;margin:0;padding-bottom:0;padding-right:0.5em}.beautify ol,.diff ol{display:table-cell;margin:0;padding:0}.box{border-style:solid;border-width:0;left:auto;margin:0;padding:0;position:absolute;z-index:10}.box button{border-radius:0;border-style:solid;border-width:0.1em;display:block;float:right;font-family:'Lucida Console','Trebuchet MS','Arial';height:1.75em;padding:0;position:absolute;right:0;text-align:center;top:0;width:1.75em;z-index:7}.box button.resize{border-width:0.05em;cursor:se-resize;font-size:1.667em;font-weight:normal;height:0.8em;line-height:0.5em;margin:-.85em 0 0;position:absolute;right:0.05em;top:100%;width:0.85em}.box button.minimize{margin:0.35em 4em 0 0}.box button.maximize{margin:0.35em 1.75em 0 0}.box button.save{margin:0.35em 6.25em 0 0}.box .buttons{float:right;margin:0}.box h3.heading{cursor:pointer;float:left;font-size:1em;height:3em;margin:0 0 -3.2em;position:relative;width:17em;z-index:6}.box h3.heading span{display:block;font-size:1.8em;padding:0.25em 0 0 0.5em}.box .body{clear:both;height:20em;margin-top:-.1em;overflow:scroll;padding:4.25em 1em 1em;position:relative;right:0;top:0;width:75em;z-index:5}.button{margin:1em 0;text-align:center}.button button{display:block;font-size:2em;height:1.5em;margin:0 auto;padding:0;width:50%}.clear{clear:both;display:block}.diff .skip{border-style:none none solid;border-width:0 0 0.1em}.diff .diff-left,.diff .diff-right{display:table-cell}.diff .diff-left{border-style:none none none solid;border-width:0 0 0 0.1em}.diff .diff-right{border-style:none none none solid;border-width:0 0 0 0.1em;margin-left:-.1em;min-width:16.5em;right:0;top:0}.diff-right .data ol{min-width:16.5em}.diff-right .data{border-style:none solid none none;border-width:0 0.1em 0 0;width:100%}.diff-right .data li{min-width:16.5em}.diff li,.diff p,.diff h3,.beautify li{font-size:1.1em}.diff li{padding-top:0.5em}.diff li em{font-style:normal;margin:0 -.09em;padding:0.05em 0}.diff p.author{border-style:solid;border-width:0.2em 0.1em 0.1em;margin:0;overflow:hidden;padding:0.4em;text-align:right}.difflabel{display:block;height:0}.file,.labeltext{font-size:0.9em;font-weight:bold;margin-bottom:1em}.file input,.labeltext input{display:inline-block;margin:0 0.7em 0 0;width:16em}.input,.output{margin:0}.options{border-radius:0.4em;clear:both;margin-bottom:1em;padding:1em 1em 3.5em;width:auto}.options input,.options label{border-style:none;display:block;float:left}.output label{text-align:right}.options p span label{font-size:1em}.options p span{display:block;float:left;font-size:1.2em;min-width:14em;padding-bottom:0.5em}.options select,#csvchar{margin:0 0 0 1em}.options span label{margin-left:0.4em}body#doc{font-size:0.8em;margin:0 auto;max-width:80em}body#doc #function_properties ul{margin:0}body#doc #function_properties ul li{font-size:0.9em;margin:0.5em 0 0 4em}body#doc ul li,body#doc ol li{font-size:1.1em}body#doc table{font-size:1em}button,a.button{border-radius:0.15em;display:block;font-weight:bold;padding:0.2em 0;width:100%}div .button{text-align:center}div button,div a.button{display:inline-block;font-weight:bold;margin:1em 0;padding:1em 2em}button:hover,a.button:hover{cursor:pointer}fieldset{border-radius:0.9em;clear:both;margin:3.5em 0 -2em;padding:0 0 0 1em}h1{float:left;font-size:2em;margin:0 0.5em 0.5em 0}h1 svg,h1 img{border-style:solid;border-width:0.05em;float:left;height:1.5em;margin-right:0.5em;width:1.5em}h1 span{font-size:0.5em}h2,h3{background:#fff;border-style:solid;border-width:0.075em;display:inline-block;font-size:1.8em;font-weight:bold;margin:0 0.5em 0.5em 0;padding:0 0.2em}h3{font-size:1.6em}h4{font-size:1.4em}input[type='radio']{margin:0 0.25em}input[type='file']{box-shadow:none}label{display:inline;font-size:1.4em}legend{border-style:solid;border-width:0.1em;font-size:1.2em;font-weight:bold;margin-left:-.25em}li{clear:both;margin:1em 0 1em 3em}li h4{display:inline;float:left;margin:0.4em 0;text-align:left;width:14em}ol li{font-size:1.4em;list-style-type:decimal}ol li li{font-size:1em}p{clear:both;font-size:1.2em;margin:0 0 1em}select{border-style:inset;border-width:0.1em;width:11.85em}strong.new{background:#ff6;font-style:italic}strong label{font-size:1em;width:inherit}textarea{display:inline-block;font-family:'Courier New',Courier,'Lucida Console',monospace;height:10em;margin:0 0 -.1em;width:100%}ul{margin:-1.4em 0 2em;padding:0}ul li{list-style-type:none}@media print{div{width:100%}html td{font-size:0.8em;white-space:normal}p,.options,#Beautify,#Minify,#diff,ul{display:none}}@media screen and (-webkit-min-device-pixel-ratio:0){.beautify .count li{padding-top:0.546em}.beautify .data li{line-height:1.3}}@media (max-width: 640px){#functionGroup{height:4em}#functionGroup.append span{margin-left:0.5em;position:relative;z-index:10}#displayOps{margin-bottom:-2em;padding-right:0.75em;width:auto}#displayOps li{padding-top:2em}#displayOps a{margin-left:1em}#diffBase,#diffNew{width:46%}#reports{display:none}.labeltext input,.file input{width:12em}#update{margin-top:2.75em}#codeInput label{display:none}#doc #dcolorScheme{margin:0 0 1em}}#webtool.white input.unchecked{background:#ccc;color:#666}.white *:focus,.white .filefocus,.white #feedreportbody .focus,.white #feedreportbody .active-focus{outline:0.1em dashed #00f}.white #beautyoutput,.white #minifyoutput{background:#ddd}.white #Beautify,.white #Minify,.white #diffBase,.white #diffNew{background:#eee;border-color:#ccc;box-shadow:0 0.2em 0.4em rgba(64,64,64,0.15)}.white #diffoutput #thirdparties{background:#eee}.white #diffoutput p em,.white #diffoutput li em{color:#c00}.white #doc .analysis thead th,.white #doc .analysis th[colspan],.white .doc .analysis thead th,.white .doc .analysis th[colspan]{background:#eef}.white #doc div,.white .doc div,#doc.white div{background:#ddd;border-color:#999}.white #doc div:hover,.white .doc div:hover,#doc.white div:hover{background:#ccc}.white #doc div div,.white .doc div div,#doc.white div div{background:#eee;border-color:#999}.white #doc div div:hover,.white .doc div div:hover,#doc.white div div:hover,#doc.white div ol:hover{background:#fff}.white #doc em,.white .doc em,#doc.white em{color:#060}.white #doc ol,.white .doc ol,#doc.white ol{background:#f8f8f8;border-color:#999}.white #doc strong,.white .doc strong,.white .box .body strong{color:#c00}#doc.white table,.white #doc table,.white .doc table,.white .box .body table{background:#fff;border-color:#999}.white #doc th,.white .doc th,#doc.white th{background:#ddd;border-left-color:#999;border-top-color:#999}.white #doc tr:hover,.white .doc tr:hover,#doc.white tr:hover{background:#ddd}.white #feedreportbody .radiogroup label{background:#f8f8f8}.white #feedreportbody .feedradio1:hover,.white #feedreportbody .active .feedradio1,.white #feedreportbody .active-focus .feedradio1{background:#f66}.white #feedreportbody .feedradio2:hover,.white #feedreportbody .active .feedradio2,.white #feedreportbody .active-focus .feedradio2{background:#f96}.white #feedreportbody .feedradio3:hover,.white #feedreportbody .active .feedradio3,.white #feedreportbody .active-focus .feedradio3{background:#fc9}.white #feedreportbody .feedradio4:hover,.white #feedreportbody .active .feedradio4,.white #feedreportbody .active-focus .feedradio4{background:#ff9}.white #feedreportbody .feedradio5:hover,.white #feedreportbody .active .feedradio5,.white #feedreportbody .active-focus .feedradio5{background:#eea}.white #feedreportbody .feedradio6:hover,.white #feedreportbody .active .feedradio6,.white #feedreportbody .active-focus .feedradio6{background:#cd9}.white #feedreportbody .feedradio7:hover,.white #feedreportbody .active .feedradio7,.white #feedreportbody .active-focus .feedradio7{background:#8d8}.white #functionGroup.append{background:#eee;border-color:#ccc;box-shadow:0 0.1em 0.2em rgba(64,64,64,0.15)}.white #introduction h2{border-color:#999;color:#333}.white #option_comment{background:#ddd;border-color:#999}.white #pdsamples li{background:#eee;border-color:#999}.white #pdsamples li div{background:#ddd;border-color:#999}.white #pdsamples li div a{color:#47a}.white #pdsamples li p a{color:#009}.white #thirdparties img,.white #diffoutput #thirdparties{border-color:#999}.white #textareaTabKey{background:#fff;border-color:#ccf}.white #thirdparties img{box-shadow:0.2em 0.2em 0.4em #999}.white #title_text{border-color:#fff;color:#333}.white #top em{color:#00f}.white #update{background:#ddd;border-color:#999;box-shadow:0 0.1em 0.2em rgba(64,64,64,0.15)}.white .analysis .bad{background-color:#ebb;color:#400}.white .analysis .good{background-color:#cec;color:#040}.white .beautify .data .l0{background:#fff}.white .beautify .data .l1{background:#fed}.white .beautify .data .l2{background:#def}.white .beautify .data .l3{background:#efe}.white .beautify .data .l4{background:#fef}.white .beautify .data .l5{background:#eef}.white .beautify .data .l6{background:#fff8cc}.white .beautify .data .l7{background:#ede}.white .beautify .data .l8{background:#efc}.white .beautify .data .l9{background:#ffd}.white .beautify .data .l10{background:#edc}.white .beautify .data .l11{background:#fdb}.white .beautify .data .l12{background:#f8f8f8}.white .beautify .data .l13{background:#ffb}.white .beautify .data .l14{background:#eec}.white .beautify .data .l15{background:#cfc}.white .beautify .data .l16{background:#eea}.white .beautify .data .c0{background:#ddd}.white .beautify .data em.s0,#doc.white .beautify .data em.s0{color:#000}.white .beautify .data em.s1,#doc.white .beautify .data em.s1{color:#f66}.white .beautify .data em.s2,#doc.white .beautify .data em.s2{color:#12f}.white .beautify .data em.s3,#doc.white .beautify .data em.s3{color:#090}.white .beautify .data em.s4,#doc.white .beautify .data em.s4{color:#d6d}.white .beautify .data em.s5,#doc.white .beautify .data em.s5{color:#7cc}.white .beautify .data em.s6,#doc.white .beautify .data em.s6{color:#c85}.white .beautify .data em.s7,#doc.white .beautify .data em.s7{color:#737}.white .beautify .data em.s8,#doc.white .beautify .data em.s8{color:#6d0}.white .beautify .data em.s9,#doc.white .beautify .data em.s9{color:#dd0}.white .beautify .data em.s10,#doc.white .beautify .data em.s10{color:#893}.white .beautify .data em.s11,#doc.white .beautify .data em.s11{color:#b97}.white .beautify .data em.s12,#doc.white .beautify .data em.s12{color:#bbb}.white .beautify .data em.s13,#doc.white .beautify .data em.s13{color:#cc3}.white .beautify .data em.s14,#doc.white .beautify .data em.s14{color:#333}.white .beautify .data em.s15,#doc.white .beautify .data em.s15{color:#9d9}.white .beautify .data em.s16,#doc.white .beautify .data em.s16{color:#880}.white .beautify .data li{color:#777}.white .box{background:#666;border-color:#999;box-shadow:0 0.4em 0.8em rgba(64,64,64,0.25)}.white .box .body{background:#eee;border-color:#888;box-shadow:0 0 0.4em rgba(64,64,64,0.75)}.white .box .body em,.white .box .body .doc em{color:#090}.white .box button{box-shadow:0 0.1em 0.2em rgba(0,0,0,0.25);text-shadow:0.1em 0.1em 0.1em rgba(0,0,0,.25)}.white .box button.maximize{background:#9c9;border-color:#030;color:#030}.white .box button.maximize:hover{background:#cfc;border-color:#060;color:#060}.white .box button.minimize{background:#bbf;border-color:#006;color:#006}.white .box button.minimize:hover{background:#eef;border-color:#228;color:#228}.white .box button.resize{background:#bbf;border-color:#446;color:#446}.white .box button.resize:hover{background:#ddf;border-color:#228;color:#228}.white .box button.save{background:#d99;border-color:#300;color:#300}.white .box button.save:hover{background:#fcc;border-color:#822;color:#822}.white .box h3.heading{background:#ddd;border-color:#888;box-shadow:0.2em 0.2em 0.4em #ccc}.white .box h3.heading:hover{background:#333;color:#eee}.white .diff,.white .beautify,.white .diff ol,.white .beautify ol,.white .diff .diff-left,.white .diff .diff-right,.white h3,.white p.author{border-color:#999}.white .diff .count li,.white .beautify .count li{background:#eed;border-color:#bbc;color:#886}.white .diff .data .delete em{background-color:#fdd;border-color:#700;color:#600}.white .diff .data .insert em{background-color:#efc;border-color:#070;color:#050}.white .diff .data .replace em{background-color:#ffd;border-color:#963;color:#630}.white .diff .delete{background-color:#fbb;border-color:#eaa}.white .diff .equal,.white .beautify .data li{background-color:#fff;border-color:#eee}.white .diff .empty{background-color:#ddd;border-color:#ccc}.white .diff .insert{background-color:#bfb;border-color:#aea}.white .diff .replace{background-color:#fea;border-color:#dd8}.white .diff .skip{background-color:#efefef;border-color:#ddd}.white .diff h3{background:#ddd;border-bottom-color:#bbc}.white .diff p.author{background:#efefef;border-top-color:#bbc}.white .file input,.white .labeltext input{border-color:#fff}.white .options{background:#eee;border-color:#ccc;box-shadow:0 0.2em 0.4em rgba(64,64,64,0.15);text-shadow:0.05em 0.05em 0.1em #ddd}.white .options input[type=text],.white .options select{border-color:#999}.white .options h2,.white #Beautify h2,.white #Minify h2,.white #diffBase h2,.white #diffNew h2{background:#eee;border-color:#eee;box-shadow:none;text-shadow:none}.white a{color:#009}.white a.button:hover,.white a.button:active,.white button:hover,.white button:active{background:#fee;border-color:#cbb;color:#966;text-shadow:0.05em 0.05em 0.1em #f8e8e8}.white fieldset{background:#ddd;border-color:#999}.white h1 svg{background:#eee;border-color:#999;box-shadow:0 0.1em 0.2em rgba(150,150,150,0.5)}.white h2,.white h3{background:#fefefe;border-color:#999;box-shadow:none;text-shadow:none}.white legend{background:#fff;border-color:#999;color:#333;text-shadow:none}.white div input{border-color:#999}.white textarea{border-color:#ccc;border-style:solid}.white textarea:hover{background:#eef8ff}body.white button,body.white a.button{background:#f8f8f8;border-color:#bbb;box-shadow:0 0.1em 0.2em rgba(64,64,64,0.15);color:#666;text-shadow:0.05em 0.05em 0.1em #e0e0e0}html .white,body.white{color:#333}#about_license a{display:block}</style></head><body class='white' id='webtool'><h1><a href='http://prettydiff.com/'>Pretty Diff - The difference tool</a></h1><div class="pdsavecontent"><p>Code type is set to <strong>auto</strong>. <span>Presumed language is <em>unknown</em>.</span></p><p><strong>Execution time:</strong> <em>0.620 seconds </em></p><p><strong>Number of differences:</strong> <em>92</em> differences from <em>31</em> lines of code.</p> <p>Accessibility note. &lt;em&gt; tags in the output represent presentation for variable coloring and scope.</p><div class="diff"><div class="diff-left"><h3 class="texttitle">NEW</h3><ol class="count"><li class="fold" title="folds from line 1 to line 37">- 1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li class="empty">​
</li><li class="empty">​
</li><li class="empty">​
</li><li class="fold" title="folds from line 38 to line 49">- 38</li><li>39</li><li>40</li><li>41</li><li>42</li><li>43</li><li>44</li><li>45</li><li>46</li><li>47</li><li>48</li><li>49</li><li>50</li><li class="fold" title="folds from line 51 to line 69">- 51</li><li>52</li><li>53</li><li>54</li><li>55</li><li>56</li><li>57</li><li>58</li><li>59</li><li>60</li><li>61</li><li>62</li><li>63</li><li>64</li><li>65</li><li>66</li><li>67</li><li>68</li><li>69</li><li>70</li><li>71</li><li>72</li><li>73</li><li>74</li><li>75</li><li>76</li><li>77</li><li class="fold" title="folds from line 78 to line 93">- 78</li><li>79</li><li>80</li><li>81</li><li>82</li><li>83</li><li>84</li><li>85</li><li>86</li><li>87</li><li>88</li><li>89</li><li>90</li><li>91</li><li>92</li><li>93</li><li class="empty">​
</li><li class="empty">​
</li><li class="empty">​
</li><li class="fold" title="folds from line 94 to line 151">- 94</li><li>95</li><li>96</li><li>97</li><li>98</li><li>99</li><li>100</li><li>101</li><li>102</li><li>103</li><li>104</li><li>105</li><li>106</li><li>107</li><li>108</li><li>109</li><li>110</li><li>111</li><li>112</li><li>113</li><li>114</li><li>115</li><li>116</li><li>117</li><li>118</li><li>119</li><li>120</li><li>121</li><li>122</li><li>123</li><li>124</li><li>125</li><li>126</li><li>127</li><li>128</li><li>129</li><li>130</li><li>131</li><li>132</li><li>133</li><li>134</li><li>135</li><li>136</li><li>137</li><li>138</li><li>139</li><li>140</li><li>141</li><li>142</li><li>143</li><li>144</li><li>145</li><li>146</li><li>147</li><li>148</li><li>149</li><li>150</li><li>151</li><li>152</li><li>153</li><li>154</li><li>155</li><li class="fold" title="folds from line 156 to line 260">- 156</li><li>157</li><li>158</li><li>159</li><li>160</li><li>161</li><li>162</li><li>163</li><li>164</li><li>165</li><li>166</li><li>167</li><li>168</li><li>169</li><li>170</li><li>171</li><li>172</li><li>173</li><li>174</li><li>175</li><li>176</li><li>177</li><li>178</li><li>179</li><li>180</li><li>181</li><li>182</li><li>183</li><li>184</li><li>185</li><li>186</li><li>187</li><li>188</li><li>189</li><li>190</li><li>191</li><li>192</li><li>193</li><li>194</li><li>195</li><li>196</li><li>197</li><li>198</li><li>199</li><li>200</li><li>201</li><li>202</li><li>203</li><li>204</li><li>205</li><li>206</li><li>207</li><li>208</li><li>209</li><li>210</li><li>211</li><li>212</li><li>213</li><li>214</li><li>215</li><li>216</li><li>217</li><li>218</li><li>219</li><li>220</li><li>221</li><li>222</li><li>223</li><li>224</li><li>225</li><li>226</li><li>227</li><li>228</li><li>229</li><li>230</li><li>231</li><li>232</li><li>233</li><li>234</li><li>235</li><li>236</li><li>237</li><li>238</li><li>239</li><li>240</li><li>241</li><li>242</li><li>243</li><li>244</li><li>245</li><li>246</li><li>247</li><li>248</li><li>249</li><li>250</li><li>251</li><li>252</li><li>253</li><li>254</li><li>255</li><li>256</li><li>257</li><li>258</li><li>259</li><li>260</li><li>261</li><li class="fold" title="folds from line 262 to line 265">- 262</li><li>263</li><li>264</li><li>265</li><li>266</li><li class="fold" title="folds from line 267 to line 294">- 267</li><li>268</li><li>269</li><li>270</li><li>271</li><li>272</li><li>273</li><li>274</li><li>275</li><li>276</li><li>277</li><li>278</li><li>279</li><li>280</li><li>281</li><li>282</li><li>283</li><li>284</li><li>285</li><li>286</li><li>287</li><li>288</li><li>289</li><li>290</li><li>291</li><li>292</li><li>293</li><li>294</li><li>295</li><li>296</li><li>297</li><li>298</li><li>299</li><li class="empty">​
</li><li class="fold" title="folds from line 300 to line 350">- 300</li><li>301</li><li>302</li><li>303</li><li>304</li><li>305</li><li>306</li><li>307</li><li>308</li><li>309</li><li>310</li><li>311</li><li>312</li><li>313</li><li>314</li><li>315</li><li>316</li><li>317</li><li>318</li><li>319</li><li>320</li><li>321</li><li>322</li><li>323</li><li>324</li><li>325</li><li>326</li><li>327</li><li>328</li><li>329</li><li>330</li><li>331</li><li>332</li><li>333</li><li>334</li><li>335</li><li>336</li><li>337</li><li>338</li><li>339</li><li>340</li><li>341</li><li>342</li><li>343</li><li>344</li><li>345</li><li>346</li><li>347</li><li>348</li><li>349</li><li>350</li><li>351</li><li class="fold" title="folds from line 352 to line 356">- 352</li><li>353</li><li>354</li><li>355</li><li>356</li><li class="empty">​
</li><li class="empty">​
</li><li class="empty">​
</li><li class="fold" title="folds from line 357 to line 451">- 357</li><li>358</li><li>359</li><li>360</li><li>361</li><li>362</li><li>363</li><li>364</li><li>365</li><li>366</li><li>367</li><li>368</li><li>369</li><li>370</li><li>371</li><li>372</li><li>373</li><li>374</li><li>375</li><li>376</li><li>377</li><li>378</li><li>379</li><li>380</li><li>381</li><li>382</li><li>383</li><li>384</li><li>385</li><li>386</li><li>387</li><li>388</li><li>389</li><li>390</li><li>391</li><li>392</li><li>393</li><li>394</li><li>395</li><li>396</li><li>397</li><li>398</li><li>399</li><li>400</li><li>401</li><li>402</li><li>403</li><li>404</li><li>405</li><li>406</li><li>407</li><li>408</li><li>409</li><li>410</li><li>411</li><li>412</li><li>413</li><li>414</li><li>415</li><li>416</li><li>417</li><li>418</li><li>419</li><li>420</li><li>421</li><li>422</li><li>423</li><li>424</li><li>425</li><li>426</li><li>427</li><li>428</li><li>429</li><li>430</li><li>431</li><li>432</li><li>433</li><li>434</li><li>435</li><li>436</li><li>437</li><li>438</li><li>439</li><li>440</li></ol><ol class="data"><li class="equal">#include &lt; ctype.h &gt; #include &lt; fcntl.h &gt; #include "redirection.h"
</li><li class="equal">#include &lt; stdio.h &gt; #include &lt; stdlib.h &gt; #include &lt; stdbool.h &gt; #include &lt; unistd.h &gt; #include &lt; string.h &gt; #include &lt; stdlib.h &gt; #include &lt; sys / stat.h &gt; #include &lt; sys / types.h &gt; #include &lt; sys / wait.h &gt; #include &lt; string.h &gt; #include "swish.h"
</li><li class="equal">#include "wolfie.h"
</li><li class="equal">#include "sys/time.h"
</li><li class="equal">#define MAX_INPUT 1024
</li><li class="equal">#define SHELL_PROMPT "swish&gt;"
</li><li class="equal">#define MAX_PATH_LENGTH 255
</li><li class="equal">#define CH_DIR "cd"
</li><li class="equal">#define PRT_WRK_DIR "pwd"
</li><li class="equal">#define EXIT "exit"
</li><li class="equal">#define ECHO "echo"
</li><li class="equal">#define SET "set"
</li><li class="equal">#define WOLFIE "wolfie"
</li><li class="equal">#define ESC_KEY '\033'
</li><li class="equal">#define DELIMITERS " \r\n\t"
</li><li class="equal">#define REDIR_DELIM " &lt;|&gt;\n\t"
</li><li class="equal">#define PATH_ENV "PATH"
</li><li class="equal">#define HOME_ENV "HOME"
</li><li class="equal">#define BACKGROUND "bg"
</li><li class="equal">#define FOREGROUND "fg"
</li><li class="equal">#define JOBS "jobs"
</li><li class="equal">#define PATH_DELIM ":"
</li><li class="equal">#define ERROR_ARGS "Invalid Arguments\n"
</li><li class="equal">#define ARG_LOC 0
</li><li class="equal">#define PATH_LOC 1
</li><li class="equal">#define OPEN_BRK "["
</li><li class="equal">#define CLOSE_BRK "] "
</li><li class="equal">#define TMP_FILE "~.tmp"
</li><li class="equal">#define _XOPEN_SOURCE 500
</li><li class="equal">#define INVALID_FILE "Invalid File"
</li><li class="equal">#define WAIT_ANY - 1
</li><li class="equal">#define run(msg) fprintf(stderr, "RUNNING: %s\n", msg)
</li><li class="equal">#define end(msg, ex) fprintf(stderr, "ENDED: %s %d\n", msg, ex)
</li><li class="equal">#define time(rel, usr, sys) write(2, "TIME: real=%ds user=%ds system=%ds\n", rel, usr, sys);
</li><li class="equal">static int arg_cnt = 0;
</li><li class="equal">static int tflag = 0;
</li><li class="equal">static int dflag = 0;
</li><li class="empty">​</li><li class="empty">​</li><li class="empty">​</li><li class="equal">extern char ** environ;
</li><li class="equal">static history * hist;
</li><li class="equal">static char cmd[MAX_INPUT];
</li><li class="equal">static char cmd_line[MAX_INPUT];
</li><li class="equal">char * token_array[MAX_INPUT];
</li><li class="equal">int built_in(command * cmd, int ac);
</li><li class="equal">void change_directory(char * path);
</li><li class="equal">int check_key_press(char ** c, int position);
</li><li class="equal">void print_time();
</li><li class="equal">void execute_cmd(command * cmd, int a);
</li><li class="equal">char * get_cur_wrk_dir(void);
</li><li class="equal">void get_input(void);
</li><li class="replace">int input_file(char * argv[], command * cmd<em>, char ** tok_arr</em>);
</li><li class="equal">void initialize_cmd(command * cmd, char ** token_array);
</li><li class="equal">int isalnumvar(char * str);
</li><li class="equal">int is_redir_symbol(char c);
</li><li class="equal">void left_shift_cmd(int shift_amt);
</li><li class="equal">void print_prompt(char * prompt);
</li><li class="equal">void print_tokens(char ** tok_arr);
</li><li class="equal">void print_working_dir(void);
</li><li class="equal">int set_variable(char ** var_value, int a);
</li><li class="equal">int tokenize_input(char * input_str, char *** token_array, int n_tok_arr, char * delimiters);
</li><li class="equal">void valid_var(char ** args_value, int ar);
</li><li class="equal">char prompt[MAX_PATH_LENGTH];
</li><li class="equal">int file_exists(char ** file_path, struct stat a);
</li><li class="equal">int main(int argc, char * argv[], char ** envp) {
</li><li class="equal">    prompt[0] = '\0';
</li><li class="equal">    int arg_cnt = 0;
</li><li class="equal">    command * cur_cmd = (command *) malloc(sizeof (command));
</li><li class="equal">    char ** tokarrp = malloc(sizeof (token_array));
</li><li class="equal">    tokarrp = token_array;
</li><li class="equal">    bool finished = false;
</li><li class="replace">    if (<em>a</em>r<em>g</em>c<em></em> <em>&gt;</em> <em>1)</em> <em>{</em>
</li><li class="replace">        <em>i</em>f<em></em> <em>(!strcmp(</em> <em>* (argv + </em>1<em>), "-d")) </em>
</li><li class="replace">    <em></em> <em></em> <em></em> <em></em> <em></em> <em></em> <em></em>  dflag = 1;
</li><li class="replace">        <em>i</em>f<em></em> <em>(!strcmp(</em> <em>* (argv + </em>1<em>), "-t")) </em>
</li><li class="replace">    <em></em> <em></em> <em></em> <em></em> <em></em> <em></em> <em></em> <em> </em>tflag<em></em> = 1;
</li><li class="replace">    <em>}</em>
</li><li class="delete">    if (argc &gt; 1 &amp;&amp; (dflag == 0) &amp;&amp; (tflag == 0)) 
</li><li class="delete">        return input_file(argv, cur_cmd, tokarrp);
</li><li class="equal">    
</li><li class="equal">    while (!finished) {
</li><li class="equal">        memset(cmd, '\0', strlen(cmd));
</li><li class="equal">        memset(cmd_line, '\0', strlen(cmd_line));
</li><li class="equal">        print_prompt(prompt);
</li><li class="equal">        get_input();
</li><li class="equal">        arg_cnt = tokenize_input(cmd, &amp; tokarrp, sizeof (cmd), DELIMITERS);
</li><li class="equal">        if (arg_cnt &lt; 1) {
</li><li class="equal">            continue;
</li><li class="equal">        }
</li><li class="equal">        initialize_cmd(cur_cmd, token_array);
</li><li class="equal">        execute_cmd(cur_cmd, arg_cnt);
</li><li class="equal">    }
</li><li class="equal">    memset(cmd, '\0', strlen(cmd));
</li><li class="equal">    return 0;
</li><li class="equal">}
</li><li class="empty">​</li><li class="empty">​</li><li class="empty">​</li><li class="equal">int check_key_press(char ** c, int position) {
</li><li class="equal">    int rv = 0;
</li><li class="equal">    switch ( ** c) {
</li><li class="equal">    case '\033':
</li><li class="equal">        getchar();
</li><li class="equal">        switch (getchar()) {
</li><li class="equal">        case 'A':
</li><li class="equal">            puts("Up arrow pressed\n");
</li><li class="equal">            break;
</li><li class="equal">        case 'B':
</li><li class="equal">            puts("Down arrow pressed\n");
</li><li class="equal">            break;
</li><li class="equal">        case 'C':
</li><li class="equal">            puts("Right arrow pressed\n");
</li><li class="equal">            break;
</li><li class="equal">        case 'D':
</li><li class="equal">            puts("Left arrow pressed\n");
</li><li class="equal">            break;
</li><li class="equal">        default:
</li><li class="equal">            break;
</li><li class="equal">        }
</li><li class="equal">        break;
</li><li class="equal">    case '\004':
</li><li class="equal">        break;
</li><li class="equal">    }
</li><li class="equal">    return rv;
</li><li class="equal">}
</li><li class="equal">void left_shift_cmd(int shift_amt) {
</li><li class="equal">    char * cursor = cmd;
</li><li class="equal">    char * shifted_cursor = cmd + shift_amt;
</li><li class="equal">    while (( * cursor++ = *shifted_cursor++)) ;
</li><li class="equal">    
</li><li class="equal">* cursor = '\0';
</li><li class="equal">}
</li><li class="equal">void print_prompt(char * prompt) {
</li><li class="equal">    memset(prompt, '\0', strlen(prompt));
</li><li class="equal">    mystrcat(prompt, OPEN_BRK);
</li><li class="equal">    mystrcat(prompt, get_cur_wrk_dir());
</li><li class="equal">    mystrcat(prompt, CLOSE_BRK);
</li><li class="equal">    mystrcat(prompt, SHELL_PROMPT);
</li><li class="equal">    write(STDOUT, prompt, strlen(prompt));
</li><li class="equal">}
</li><li class="equal">void get_input() {
</li><li class="equal">    char * cursor;
</li><li class="equal">    unsigned short count;
</li><li class="equal">    char last_char;
</li><li class="equal">    int rv;
</li><li class="equal">    for (rv = 1, count = 0, cursor = cmd, last_char = 1; rv &amp;&amp; (++count &lt; (MAX_INPUT - 1)) &amp;&amp; !(last_char == '\n' || last_char == '\0'); cursor++) {
</li><li class="equal">        rv = read(STDIN, cursor, 1);
</li><li class="equal">        check_key_press( &amp; cursor, count);
</li><li class="equal">        last_char = *cursor;
</li><li class="equal">    } * cursor = '\0';
</li><li class="equal">    strcpy(cmd_line, cmd);
</li><li class="equal">}
</li><li class="equal">int tokenize_input(char * input_str, char *** tok_arr, int n_tok_arr, char * delimiters) {
</li><li class="equal">    if ( * input_str == '\n') 
</li><li class="equal">        return -1;
</li><li class="delete">    
</li><li class="delete">    const char ch = '#';
</li><li class="delete">    char * ret;
</li><li class="delete">    ret = strrchr(cmd, ch);
</li><li class="delete">    if (ret != NULL) * ret = '\0';
</li><li class="equal">    
</li><li class="equal">    int i = 0;
</li><li class="equal">    for ( * ( * tok_arr + i) = strtok(input_str, delimiters); i &lt; n_tok_arr &amp;&amp; * ( * tok_arr + i) != NULL; i++, * ( * tok_arr + i) = strtok(NULL, delimiters)) ;
</li><li class="equal">    return i;
</li><li class="equal">}
</li><li class="equal">void initialize_cmd(command * u_cmd, char ** tok_arr) {
</li><li class="equal">    u_cmd - &gt; cmd_line = malloc(sizeof (cmd_line));
</li><li class="equal">    u_cmd - &gt; cmd_line = cmd_line;
</li><li class="equal">    u_cmd - &gt; command = malloc(sizeof (tok_arr[0]));
</li><li class="equal">    u_cmd - &gt; command = tok_arr[0];
</li><li class="equal">    u_cmd - &gt; args = malloc(sizeof ((tok_arr)));
</li><li class="equal">    u_cmd - &gt; args = tok_arr;
</li><li class="equal">    if (hist == NULL) {
</li><li class="equal">        hist = malloc(sizeof (history));
</li><li class="equal">    }
</li><li class="equal">    hist - &gt; prev_cmd = malloc(sizeof ( * u_cmd));
</li><li class="equal">    hist - &gt; prev_cmd = hist - &gt; cur_cmd;
</li><li class="equal">    hist - &gt; cur_cmd = malloc(sizeof ( * u_cmd));
</li><li class="equal">    hist - &gt; cur_cmd = u_cmd;
</li><li class="equal">}
</li><li class="equal">int is_redir_cmd(command * cmd, int ac) {
</li><li class="equal">    int rv = 0, i;
</li><li class="equal">    for (i = 0; i &lt; ac &amp;&amp; rv != 1; i++) {
</li><li class="equal">        rv = (is_redir_symbol( ** (cmd - &gt; args + i))) ? 1 : 0;
</li><li class="equal">    }
</li><li class="equal">    return rv;
</li><li class="equal">}
</li><li class="equal">int is_redir_symbol(char c) {
</li><li class="equal">    return c == REDIR_TO_PROG || c == STDOUT_TO_FILE || c == FILE_TO_STDOUT;
</li><li class="equal">}
</li><li class="equal">void exec_redir(command * cur_cmd, int ac) {
</li><li class="equal">    int i, arg_cnt;
</li><li class="equal">    int fd[2];
</li><li class="equal">    int save_in, save_out, output_fd = -1, input_fd = -1;
</li><li class="equal">    char * cur_tok, * next_tok;
</li><li class="equal">    char cur_tok_c;
</li><li class="equal">    char * orig_cmd_line = malloc(strlen(cur_cmd - &gt; cmd_line));
</li><li class="equal">    strcpy(orig_cmd_line, cur_cmd - &gt; cmd_line);
</li><li class="equal">    command * new_cmd = malloc(sizeof (command));
</li><li class="equal">    char ** tok_arr = malloc(sizeof (token_array));
</li><li class="equal">    for (i = 0; i &lt; ac; i++) {
</li><li class="equal">        cur_tok = *(token_array + i);
</li><li class="equal">        cur_tok_c = cur_tok[0];
</li><li class="equal">        if (is_redir_symbol(cur_tok_c)) {
</li><li class="equal">            next_tok = malloc(strlen( * (token_array + i + 1)));
</li><li class="equal">            next_tok = *(token_array + i + 1);
</li><li class="equal">            switch (cur_tok_c) {
</li><li class="equal">            case STDOUT_TO_FILE:
</li><li class="equal">                save_out = dup(STDOUT_FILENO);
</li><li class="equal">                char * file = next_tok;
</li><li class="equal">                arg_cnt = tokenize_input(cur_cmd - &gt; cmd_line, &amp; tok_arr, i - 1, REDIR_DELIM);
</li><li class="equal">                initialize_cmd(new_cmd, tok_arr);
</li><li class="equal">                output_fd = open(file, O_RDWR | O_CREAT, S_IRWXU | S_IRWXG | S_IRWXO);
</li><li class="equal">                if (output_fd &lt; 0) {
</li><li class="equal">                    puts("Error in accessing that file. Program will now exit.");
</li><li class="equal">                    break;
</li><li class="equal">                }
</li><li class="equal">                if (close(STDOUT_FILENO) &lt; 0) {
</li><li class="equal">                    puts("Error in closing stdout. Program will now exit.\n");
</li><li class="equal">                    break;
</li><li class="equal">                }
</li><li class="equal">                if (dup(output_fd) != STDOUT_FILENO) {
</li><li class="equal">                    puts("File descriptor is not equal to stdout. Program will now exit.\n");
</li><li class="equal">                    break;
</li><li class="equal">                }
</li><li class="equal">                close(output_fd);
</li><li class="equal">                execute_cmd(new_cmd, arg_cnt);
</li><li class="equal">                dup2(save_out, STDOUT_FILENO);
</li><li class="equal">                close(save_out);
</li><li class="equal">                strcpy(cur_cmd - &gt; cmd_line, orig_cmd_line);
</li><li class="equal">                break;
</li><li class="equal">            case FILE_TO_STDOUT:
</li><li class="equal">                save_in = dup(STDIN_FILENO);
</li><li class="equal">                file = next_tok;
</li><li class="equal">                arg_cnt = tokenize_input(cur_cmd - &gt; cmd_line, &amp; tok_arr, i - 1, REDIR_DELIM);
</li><li class="equal">                initialize_cmd(new_cmd, tok_arr);
</li><li class="equal">                input_fd = open(file, O_RDONLY, S_IRUSR | S_IWUSR);
</li><li class="equal">                if (input_fd &lt; 0) {
</li><li class="equal">                    puts("Error in accessing that file. Program will now exit.\n");
</li><li class="equal">                    break;
</li><li class="equal">                }
</li><li class="equal">                if (close(STDIN_FILENO) &lt; 0) {
</li><li class="equal">                    puts("Error in closing stdout. Program will now exit.\n");
</li><li class="equal">                    break;
</li><li class="equal">                }
</li><li class="equal">                if (dup(input_fd) != STDIN_FILENO) {
</li><li class="equal">                    puts("File descriptor is not equal to standard output. Program will now exit.\n");
</li><li class="equal">                    break;
</li><li class="equal">                }
</li><li class="equal">                close(input_fd);
</li><li class="equal">                execute_cmd(new_cmd, arg_cnt);
</li><li class="equal">                dup2(save_in, fileno(stdin));
</li><li class="equal">                close(save_in);
</li><li class="equal">                strcpy(cur_cmd - &gt; cmd_line, orig_cmd_line);
</li><li class="equal">                break;
</li><li class="equal">            case REDIR_TO_PROG:
</li><li class="equal">                arg_cnt = tokenize_input(cur_cmd - &gt; cmd_line, &amp; tok_arr, i - 1, REDIR_DELIM);
</li><li class="equal">                initialize_cmd(new_cmd, tok_arr);
</li><li class="equal">                pipe(fd);
</li><li class="equal">                execute_cmd(new_cmd, arg_cnt);
</li><li class="equal">                break;
</li><li class="equal">            }
</li><li class="equal">        }
</li><li class="equal">    }
</li><li class="equal">}
</li><li class="replace">int input_file(char * argv[], command * cur_cmd<em>,</em> <em>char ** tok_arr) </em>{
</li><li class="equal">    FILE * fp;
</li><li class="equal">    fp = fopen( * (argv + 1), "r");
</li><li class="equal">    if (fp != NULL) {
</li><li class="equal">        while (fgets(cmd, MAX_INPUT, fp) != NULL) {
</li><li class="replace">            arg_cnt = tokenize_input(cmd, <em>&amp;</em> <em></em>tok<em></em>_arr<em></em>, MAX_INPUT, DELIMITERS);
</li><li class="equal">            if (arg_cnt &lt; 1) {
</li><li class="equal">                continue;
</li><li class="equal">            }
</li><li class="equal">            initialize_cmd(cur_cmd, token_array);
</li><li class="equal">            execute_cmd(cur_cmd, arg_cnt);
</li><li class="equal">        }
</li><li class="equal">        fclose(fp);
</li><li class="equal">        return 0;
</li><li class="equal">    }
</li><li class="equal">    write(2, INVALID_FILE, strlen(INVALID_FILE));
</li><li class="equal">    return 1;
</li><li class="equal">}
</li><li class="equal">void print_tokens(char ** tok_arr) {
</li><li class="equal">    int i;
</li><li class="equal">    for (i = 0; *(tok_arr + i) != NULL; i++) {
</li><li class="equal">        printf("token:%s\n", * (tok_arr + i));
</li><li class="equal">    }
</li><li class="equal">}
</li><li class="equal">void execute_cmd(command * cmd, int ac) {
</li><li class="equal">    int status = 0;
</li><li class="equal">    pid_t wpid;
</li><li class="equal">    struct stat file_stat;
</li><li class="equal">    char * cmd_val = cmd - &gt; command;
</li><li class="equal">    char val;
</li><li class="equal">    char * ptr;
</li><li class="equal">    if (dflag) {
</li><li class="equal">        run(cmd - &gt; command);
</li><li class="equal">    }
</li><li class="replace">    if (<em></em>i<em>s</em>_<em>red</em>i<em>r_</em>cmd<em>(cmd</em>, ac)) {
</li><li class="replace">        <em>exec_red</em>i<em>r</em>(<em></em>cm<em></em>d<em></em>, <em>ac</em>)<em>;</em>
</li><li class="replace">    <em>}</em> <em>else</em> <em>if</em> <em>(!bui</em>l<em>t_</em>i<em>n(cm</em>d<em>, </em>a<em></em>c<em>))</em> <em>{</em>
</li><li class="replace">        <em>if (!strcmp(cmd_val, ECHO)) {</em>
</li><li class="replace">        <em></em> <em></em> <em></em> <em></em> <em>v</em>a<em>lid_va</em>r<em>(</em>c<em>md</em> - <em>&gt;</em> <em>args,</em> <em>ac</em>)<em>;</em>
</li><li class="empty">​</li><li class="equal">        }
</li><li class="equal">        cmd - &gt; pid = fork();
</li><li class="equal">        if (cmd - &gt; pid == -1) {
</li><li class="equal">            exit(1);
</li><li class="equal">        } else if (cmd - &gt; pid == 0) {
</li><li class="equal">            if (file_exists( &amp; cmd - &gt; command, file_stat)) {
</li><li class="equal">                printf("executing command\n");
</li><li class="equal">                execvp(cmd - &gt; command, cmd - &gt; args);
</li><li class="equal">                printf("%s: command not found\n", cmd - &gt; command);
</li><li class="equal">                exit(1);
</li><li class="equal">            } else {
</li><li class="equal">                puts("File not found\n");
</li><li class="equal">                exit(1);
</li><li class="equal">            }
</li><li class="equal">        } else {
</li><li class="equal">            do {
</li><li class="equal">                wpid = waitpid(cmd - &gt; pid, &amp; status, WCONTINUED | WUNTRACED);
</li><li class="equal">                val = WEXITSTATUS(status) + '0';
</li><li class="equal">                ptr = &amp;val;
</li><li class="equal">                setenv("?", ptr, 1);
</li><li class="equal">            } while (wpid &gt; 0);
</li><li class="equal">            if (dflag) 
</li><li class="equal">                end(cmd - &gt; command, WEXITSTATUS(status));
</li><li class="equal">        }
</li><li class="equal">    }
</li><li class="equal">}
</li><li class="equal">void valid_var(char ** args, int a) {
</li><li class="equal">    char * beg;
</li><li class="equal">    int i = 1;
</li><li class="equal">    for (i = 1; i &lt; a; i++) {
</li><li class="equal">        beg = memchr( * (args + i), '$', strlen( * (args + i)));
</li><li class="equal">        if (beg == NULL) 
</li><li class="equal">            continue;
</li><li class="equal">        else if (isalnumvar(beg)) { * (args + i) = getenv(++beg);
</li><li class="equal">        }
</li><li class="equal">    }
</li><li class="equal">}
</li><li class="equal">int built_in(command * cmd, int ac) {
</li><li class="equal">    char * cmd_val = cmd - &gt; command;
</li><li class="equal">    if (!strcmp(cmd_val, EXIT)) {
</li><li class="equal">        exit(1);
</li><li class="equal">    } else if (!strcmp(cmd_val, CH_DIR)) {
</li><li class="equal">        change_directory(cmd - &gt; args[PATH_LOC]);
</li><li class="equal">        return 1;
</li><li class="equal">    } else if (!strcmp(cmd_val, PRT_WRK_DIR)) {
</li><li class="equal">        print_working_dir();
</li><li class="equal">        return 1;
</li><li class="equal">    } else if (!strcmp(cmd_val, SET)) {
</li><li class="equal">        set_variable(cmd - &gt; args, ac);
</li><li class="equal">        return 1;
</li><li class="equal">    } else if (!strcmp(cmd_val, WOLFIE)) {
</li><li class="delete">        wolfie();
</li><li class="equal">        return 1;
</li><li class="equal">    } else if (!strcmp(cmd_val, BACKGROUND)) {
</li><li class="equal">        return 1;
</li><li class="equal">    } else if (!strcmp(cmd_val, FOREGROUND)) {
</li><li class="equal">        return 1;
</li><li class="empty">​</li><li class="empty">​</li><li class="empty">​</li><li class="equal">    } else if (!strcmp(cmd_val, JOBS)) {
</li><li class="equal">        return 1;
</li><li class="equal">    }
</li><li class="equal">    return 0;
</li><li class="equal">}
</li><li class="equal">int isalnumvar(char * str) {
</li><li class="equal">    int i = 1;
</li><li class="equal">    if (strlen(str) == 2 &amp;&amp; * (str + 1) == '?') 
</li><li class="equal">        return 1;
</li><li class="equal">    
</li><li class="equal">    for (i = 1; i &lt; strlen(str); i++) {
</li><li class="equal">        if (isalnum( * (str + i))) 
</li><li class="equal">            continue;
</li><li class="equal">        else {
</li><li class="equal">            return 0;
</li><li class="equal">        }
</li><li class="equal">    }
</li><li class="equal">    return 1;
</li><li class="equal">}
</li><li class="equal">int set_variable(char ** args, int count) {
</li><li class="equal">    if (count == 1 || count == 3 || count &gt; 4) {
</li><li class="equal">        return 1;
</li><li class="equal">    }
</li><li class="equal">    if (count == 4) {
</li><li class="equal">        if ( ** (args + 2) == '=') {
</li><li class="equal">            setenv( * (args + 1), * (args + 3), 1);
</li><li class="equal">            return 0;
</li><li class="equal">        } else {
</li><li class="equal">            return 1;
</li><li class="equal">        }
</li><li class="equal">    }
</li><li class="equal">    char * var = malloc(sizeof (char) * (strlen( * (args + 1))));
</li><li class="equal">    char * ret;
</li><li class="equal">    char * val = malloc(sizeof (char) * strlen( * (args + 1)));;
</li><li class="equal">    char eq = '=';
</li><li class="equal">    if (count == 2) {
</li><li class="equal">        ret = memchr( * (args + 1), eq, strlen( * (args + 1)));
</li><li class="equal">        memcpy(var, * (args + 1), ret - * (args + 1));
</li><li class="equal">        ret++;
</li><li class="equal">        memcpy(val, ret, strlen(ret));
</li><li class="equal">        setenv(var, val, 1);
</li><li class="equal">    }
</li><li class="equal">    free(var);
</li><li class="equal">    free(val);
</li><li class="equal">    return 0;
</li><li class="equal">}
</li><li class="equal">void change_directory(char * path) {
</li><li class="equal">    if (!path) {
</li><li class="equal">        chdir(getenv(HOME_ENV));
</li><li class="equal">    } else if (chdir(path) != 0) {
</li><li class="equal">        printf("Failed to find %s\n", path);
</li><li class="equal">    }
</li><li class="equal">}
</li><li class="equal">char * get_cur_wrk_dir() {
</li><li class="equal">    return getcwd(NULL, MAX_PATH_LENGTH);
</li><li class="equal">}
</li><li class="equal">void print_working_dir() {
</li><li class="equal">    char * dir_path = get_cur_wrk_dir();
</li><li class="equal">    write(STDOUT, dir_path, strlen(dir_path));
</li><li class="equal">    write(STDOUT, "\n", 1);
</li><li class="equal">}
</li><li class="equal">int file_exists(char ** file_path, struct stat file_stat) {
</li><li class="equal">    char * orig_file_path;
</li><li class="equal">    char * concat_file_path;
</li><li class="equal">    orig_file_path = malloc(strlen( * file_path) + 2);
</li><li class="equal">    if ( ** file_path != '/') {
</li><li class="equal">        mystrcat(orig_file_path, "/");
</li><li class="equal">    }
</li><li class="equal">    mystrcat(orig_file_path, * file_path);
</li><li class="equal">    int ret_val = 0;
</li><li class="equal">    char * cur_path;
</li><li class="equal">    char * all_paths = getenv(PATH_ENV);
</li><li class="equal">    cur_path = strtok(all_paths, PATH_DELIM);
</li><li class="equal">    while (cur_path != NULL) {
</li><li class="equal">        concat_file_path = malloc(strlen(orig_file_path) + strlen(cur_path) + 1);
</li><li class="equal">        mystrcat(concat_file_path, cur_path);
</li><li class="equal">        mystrcat(concat_file_path, orig_file_path);
</li><li class="equal">        if ((ret_val = !stat(concat_file_path, &amp; file_stat))) { * file_path = concat_file_path;
</li><li class="equal">            break;
</li><li class="equal">        }
</li><li class="equal">        cur_path = strtok(NULL, PATH_DELIM);
</li><li class="equal">    }
</li><li class="equal">    return ret_val;
</li><li class="equal">}
</li></ol></div><div class="diff-right"><h3 class="texttitle">OLD</h3><ol class="count" style="cursor:w-resize"><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li>38</li><li>39</li><li>40</li><li>41</li><li>42</li><li>43</li><li>44</li><li>45</li><li>46</li><li>47</li><li>48</li><li>49</li><li>50</li><li>51</li><li>52</li><li>53</li><li>54</li><li>55</li><li>56</li><li>57</li><li>58</li><li>59</li><li>60</li><li>61</li><li>62</li><li>63</li><li>64</li><li>65</li><li>66</li><li>67</li><li>68</li><li>69</li><li>70</li><li>71</li><li>72</li><li>73</li><li>74</li><li>75</li><li>76</li><li>77</li><li>78</li><li class="empty">​
</li><li class="empty">​
</li><li>79</li><li>80</li><li>81</li><li>82</li><li>83</li><li>84</li><li>85</li><li>86</li><li>87</li><li>88</li><li>89</li><li>90</li><li>91</li><li>92</li><li>93</li><li>94</li><li>95</li><li>96</li><li>97</li><li>98</li><li>99</li><li>100</li><li>101</li><li>102</li><li>103</li><li>104</li><li>105</li><li>106</li><li>107</li><li>108</li><li>109</li><li>110</li><li>111</li><li>112</li><li>113</li><li>114</li><li>115</li><li>116</li><li>117</li><li>118</li><li>119</li><li>120</li><li>121</li><li>122</li><li>123</li><li>124</li><li>125</li><li>126</li><li>127</li><li>128</li><li>129</li><li>130</li><li>131</li><li>132</li><li>133</li><li>134</li><li>135</li><li>136</li><li>137</li><li>138</li><li>139</li><li>140</li><li>141</li><li>142</li><li>143</li><li>144</li><li>145</li><li>146</li><li>147</li><li>148</li><li>149</li><li>150</li><li>151</li><li>152</li><li>153</li><li>154</li><li class="empty">​
</li><li class="empty">​
</li><li class="empty">​
</li><li class="empty">​
</li><li class="empty">​
</li><li>155</li><li>156</li><li>157</li><li>158</li><li>159</li><li>160</li><li>161</li><li>162</li><li>163</li><li>164</li><li>165</li><li>166</li><li>167</li><li>168</li><li>169</li><li>170</li><li>171</li><li>172</li><li>173</li><li>174</li><li>175</li><li>176</li><li>177</li><li>178</li><li>179</li><li>180</li><li>181</li><li>182</li><li>183</li><li>184</li><li>185</li><li>186</li><li>187</li><li>188</li><li>189</li><li>190</li><li>191</li><li>192</li><li>193</li><li>194</li><li>195</li><li>196</li><li>197</li><li>198</li><li>199</li><li>200</li><li>201</li><li>202</li><li>203</li><li>204</li><li>205</li><li>206</li><li>207</li><li>208</li><li>209</li><li>210</li><li>211</li><li>212</li><li>213</li><li>214</li><li>215</li><li>216</li><li>217</li><li>218</li><li>219</li><li>220</li><li>221</li><li>222</li><li>223</li><li>224</li><li>225</li><li>226</li><li>227</li><li>228</li><li>229</li><li>230</li><li>231</li><li>232</li><li>233</li><li>234</li><li>235</li><li>236</li><li>237</li><li>238</li><li>239</li><li>240</li><li>241</li><li>242</li><li>243</li><li>244</li><li>245</li><li>246</li><li>247</li><li>248</li><li>249</li><li>250</li><li>251</li><li>252</li><li>253</li><li>254</li><li>255</li><li>256</li><li>257</li><li>258</li><li>259</li><li>260</li><li>261</li><li>262</li><li>263</li><li>264</li><li>265</li><li>266</li><li>267</li><li>268</li><li>269</li><li>270</li><li>271</li><li>272</li><li>273</li><li>274</li><li>275</li><li>276</li><li>277</li><li>278</li><li>279</li><li>280</li><li>281</li><li>282</li><li>283</li><li>284</li><li>285</li><li>286</li><li>287</li><li>288</li><li>289</li><li>290</li><li>291</li><li>292</li><li>293</li><li>294</li><li>295</li><li>296</li><li>297</li><li>298</li><li>299</li><li>300</li><li>301</li><li>302</li><li>303</li><li>304</li><li>305</li><li>306</li><li>307</li><li>308</li><li>309</li><li>310</li><li>311</li><li>312</li><li>313</li><li>314</li><li>315</li><li>316</li><li>317</li><li>318</li><li>319</li><li>320</li><li>321</li><li>322</li><li>323</li><li>324</li><li>325</li><li>326</li><li>327</li><li>328</li><li>329</li><li>330</li><li>331</li><li>332</li><li>333</li><li>334</li><li>335</li><li>336</li><li>337</li><li>338</li><li>339</li><li>340</li><li>341</li><li>342</li><li>343</li><li>344</li><li>345</li><li>346</li><li>347</li><li>348</li><li>349</li><li>350</li><li class="empty">​
</li><li>351</li><li>352</li><li>353</li><li>354</li><li>355</li><li>356</li><li>357</li><li>358</li><li>359</li><li>360</li><li>361</li><li>362</li><li>363</li><li>364</li><li>365</li><li>366</li><li>367</li><li>368</li><li>369</li><li>370</li><li>371</li><li>372</li><li>373</li><li>374</li><li>375</li><li>376</li><li>377</li><li>378</li><li>379</li><li>380</li><li>381</li><li>382</li><li>383</li><li>384</li><li>385</li><li>386</li><li>387</li><li>388</li><li>389</li><li>390</li><li>391</li><li>392</li><li>393</li><li>394</li><li>395</li><li>396</li><li>397</li><li>398</li><li>399</li><li>400</li><li>401</li><li>402</li><li>403</li><li>404</li><li>405</li><li>406</li><li>407</li><li>408</li><li>409</li><li>410</li><li>411</li><li>412</li><li>413</li><li>414</li><li>415</li><li>416</li><li>417</li><li>418</li><li>419</li><li>420</li><li>421</li><li>422</li><li>423</li><li>424</li><li>425</li><li>426</li><li>427</li><li>428</li><li>429</li><li>430</li><li>431</li><li>432</li><li>433</li><li>434</li><li>435</li><li>436</li><li>437</li><li>438</li><li>439</li><li>440</li><li>441</li><li>442</li></ol><ol class="data"><li class="equal">#include &lt; ctype.h &gt; #include &lt; fcntl.h &gt; #include "redirection.h"
</li><li class="equal">#include &lt; stdio.h &gt; #include &lt; stdlib.h &gt; #include &lt; stdbool.h &gt; #include &lt; unistd.h &gt; #include &lt; string.h &gt; #include &lt; stdlib.h &gt; #include &lt; sys / stat.h &gt; #include &lt; sys / types.h &gt; #include &lt; sys / wait.h &gt; #include &lt; string.h &gt; #include "swish.h"
</li><li class="equal">#include "wolfie.h"
</li><li class="equal">#include "sys/time.h"
</li><li class="equal">#define MAX_INPUT 1024
</li><li class="equal">#define SHELL_PROMPT "swish&gt;"
</li><li class="equal">#define MAX_PATH_LENGTH 255
</li><li class="equal">#define CH_DIR "cd"
</li><li class="equal">#define PRT_WRK_DIR "pwd"
</li><li class="equal">#define EXIT "exit"
</li><li class="equal">#define ECHO "echo"
</li><li class="equal">#define SET "set"
</li><li class="equal">#define WOLFIE "wolfie"
</li><li class="equal">#define ESC_KEY '\033'
</li><li class="equal">#define DELIMITERS " \r\n\t"
</li><li class="equal">#define REDIR_DELIM " &lt;|&gt;\n\t"
</li><li class="equal">#define PATH_ENV "PATH"
</li><li class="equal">#define HOME_ENV "HOME"
</li><li class="equal">#define BACKGROUND "bg"
</li><li class="equal">#define FOREGROUND "fg"
</li><li class="equal">#define JOBS "jobs"
</li><li class="equal">#define PATH_DELIM ":"
</li><li class="equal">#define ERROR_ARGS "Invalid Arguments\n"
</li><li class="equal">#define ARG_LOC 0
</li><li class="equal">#define PATH_LOC 1
</li><li class="equal">#define OPEN_BRK "["
</li><li class="equal">#define CLOSE_BRK "] "
</li><li class="equal">#define TMP_FILE "~.tmp"
</li><li class="equal">#define _XOPEN_SOURCE 500
</li><li class="equal">#define INVALID_FILE "Invalid File"
</li><li class="equal">#define WAIT_ANY - 1
</li><li class="equal">#define run(msg) fprintf(stderr, "RUNNING: %s\n", msg)
</li><li class="equal">#define end(msg, ex) fprintf(stderr, "ENDED: %s %d\n", msg, ex)
</li><li class="equal">#define time(rel, usr, sys) write(2, "TIME: real=%ds user=%ds system=%ds\n", rel, usr, sys);
</li><li class="equal">static int arg_cnt = 0;
</li><li class="equal">static int tflag = 0;
</li><li class="equal">static int dflag = 0;
</li><li class="insert">static struct timeval begin;
</li><li class="insert">static struct timeval end;
</li><li class="insert">static double diff;
</li><li class="equal">extern char ** environ;
</li><li class="equal">static history * hist;
</li><li class="equal">static char cmd[MAX_INPUT];
</li><li class="equal">static char cmd_line[MAX_INPUT];
</li><li class="equal">char * token_array[MAX_INPUT];
</li><li class="equal">int built_in(command * cmd, int ac);
</li><li class="equal">void change_directory(char * path);
</li><li class="equal">int check_key_press(char ** c, int position);
</li><li class="equal">void print_time();
</li><li class="equal">void execute_cmd(command * cmd, int a);
</li><li class="equal">char * get_cur_wrk_dir(void);
</li><li class="equal">void get_input(void);
</li><li class="replace">int input_file(char * argv[], command * cmd<em></em>);
</li><li class="equal">void initialize_cmd(command * cmd, char ** token_array);
</li><li class="equal">int isalnumvar(char * str);
</li><li class="equal">int is_redir_symbol(char c);
</li><li class="equal">void left_shift_cmd(int shift_amt);
</li><li class="equal">void print_prompt(char * prompt);
</li><li class="equal">void print_tokens(char ** tok_arr);
</li><li class="equal">void print_working_dir(void);
</li><li class="equal">int set_variable(char ** var_value, int a);
</li><li class="equal">int tokenize_input(char * input_str, char *** token_array, int n_tok_arr, char * delimiters);
</li><li class="equal">void valid_var(char ** args_value, int ar);
</li><li class="equal">char prompt[MAX_PATH_LENGTH];
</li><li class="equal">int file_exists(char ** file_path, struct stat a);
</li><li class="equal">int main(int argc, char * argv[], char ** envp) {
</li><li class="equal">    prompt[0] = '\0';
</li><li class="equal">    int arg_cnt = 0;
</li><li class="equal">    command * cur_cmd = (command *) malloc(sizeof (command));
</li><li class="equal">    char ** tokarrp = malloc(sizeof (token_array));
</li><li class="equal">    tokarrp = token_array;
</li><li class="equal">    bool finished = false;
</li><li class="replace">    if (<em>!st</em>r<em></em>c<em>mp(</em> <em>*</em> <em>(argv</em> <em>+ 1), "-d")) </em>
</li><li class="replace">        <em>d</em>f<em>lag</em> <em>=</em> <em></em>1<em>;</em>
</li><li class="replace">    <em>if</em> <em>(!strcmp(</em> <em>*</em> <em>(argv</em> <em>+</em> <em>1),</em> <em>"-t"))</em> 
</li><li class="replace">        <em>t</em>f<em>lag</em> <em>=</em> <em></em>1<em>;</em>
</li><li class="replace">    <em>if</em> <em>(argc</em> <em>&gt;</em> <em>1</em> <em>&amp;&amp;</em> <em>dflag</em> <em>&amp;&amp;</em> <em></em>tflag<em>)</em> 
</li><li class="replace">    <em>    return input_file(argv, cur_cmd);</em>
</li><li class="empty">​</li><li class="empty">​</li><li class="equal">    
</li><li class="equal">    while (!finished) {
</li><li class="equal">        memset(cmd, '\0', strlen(cmd));
</li><li class="equal">        memset(cmd_line, '\0', strlen(cmd_line));
</li><li class="equal">        print_prompt(prompt);
</li><li class="equal">        get_input();
</li><li class="equal">        arg_cnt = tokenize_input(cmd, &amp; tokarrp, sizeof (cmd), DELIMITERS);
</li><li class="equal">        if (arg_cnt &lt; 1) {
</li><li class="equal">            continue;
</li><li class="equal">        }
</li><li class="equal">        initialize_cmd(cur_cmd, token_array);
</li><li class="equal">        execute_cmd(cur_cmd, arg_cnt);
</li><li class="equal">    }
</li><li class="equal">    memset(cmd, '\0', strlen(cmd));
</li><li class="equal">    return 0;
</li><li class="equal">}
</li><li class="insert">void print_time() {
</li><li class="insert">    struct rusage
</li><li class="insert">}
</li><li class="equal">int check_key_press(char ** c, int position) {
</li><li class="equal">    int rv = 0;
</li><li class="equal">    switch ( ** c) {
</li><li class="equal">    case '\033':
</li><li class="equal">        getchar();
</li><li class="equal">        switch (getchar()) {
</li><li class="equal">        case 'A':
</li><li class="equal">            puts("Up arrow pressed\n");
</li><li class="equal">            break;
</li><li class="equal">        case 'B':
</li><li class="equal">            puts("Down arrow pressed\n");
</li><li class="equal">            break;
</li><li class="equal">        case 'C':
</li><li class="equal">            puts("Right arrow pressed\n");
</li><li class="equal">            break;
</li><li class="equal">        case 'D':
</li><li class="equal">            puts("Left arrow pressed\n");
</li><li class="equal">            break;
</li><li class="equal">        default:
</li><li class="equal">            break;
</li><li class="equal">        }
</li><li class="equal">        break;
</li><li class="equal">    case '\004':
</li><li class="equal">        break;
</li><li class="equal">    }
</li><li class="equal">    return rv;
</li><li class="equal">}
</li><li class="equal">void left_shift_cmd(int shift_amt) {
</li><li class="equal">    char * cursor = cmd;
</li><li class="equal">    char * shifted_cursor = cmd + shift_amt;
</li><li class="equal">    while (( * cursor++ = *shifted_cursor++)) ;
</li><li class="equal">    
</li><li class="equal">* cursor = '\0';
</li><li class="equal">}
</li><li class="equal">void print_prompt(char * prompt) {
</li><li class="equal">    memset(prompt, '\0', strlen(prompt));
</li><li class="equal">    mystrcat(prompt, OPEN_BRK);
</li><li class="equal">    mystrcat(prompt, get_cur_wrk_dir());
</li><li class="equal">    mystrcat(prompt, CLOSE_BRK);
</li><li class="equal">    mystrcat(prompt, SHELL_PROMPT);
</li><li class="equal">    write(STDOUT, prompt, strlen(prompt));
</li><li class="equal">}
</li><li class="equal">void get_input() {
</li><li class="equal">    char * cursor;
</li><li class="equal">    unsigned short count;
</li><li class="equal">    char last_char;
</li><li class="equal">    int rv;
</li><li class="equal">    for (rv = 1, count = 0, cursor = cmd, last_char = 1; rv &amp;&amp; (++count &lt; (MAX_INPUT - 1)) &amp;&amp; !(last_char == '\n' || last_char == '\0'); cursor++) {
</li><li class="equal">        rv = read(STDIN, cursor, 1);
</li><li class="equal">        check_key_press( &amp; cursor, count);
</li><li class="equal">        last_char = *cursor;
</li><li class="equal">    } * cursor = '\0';
</li><li class="equal">    strcpy(cmd_line, cmd);
</li><li class="equal">}
</li><li class="equal">int tokenize_input(char * input_str, char *** tok_arr, int n_tok_arr, char * delimiters) {
</li><li class="equal">    if ( * input_str == '\n') 
</li><li class="equal">        return -1;
</li><li class="empty">​</li><li class="empty">​</li><li class="empty">​</li><li class="empty">​</li><li class="empty">​</li><li class="equal">    
</li><li class="equal">    int i = 0;
</li><li class="equal">    for ( * ( * tok_arr + i) = strtok(input_str, delimiters); i &lt; n_tok_arr &amp;&amp; * ( * tok_arr + i) != NULL; i++, * ( * tok_arr + i) = strtok(NULL, delimiters)) ;
</li><li class="equal">    return i;
</li><li class="equal">}
</li><li class="equal">void initialize_cmd(command * u_cmd, char ** tok_arr) {
</li><li class="equal">    u_cmd - &gt; cmd_line = malloc(sizeof (cmd_line));
</li><li class="equal">    u_cmd - &gt; cmd_line = cmd_line;
</li><li class="equal">    u_cmd - &gt; command = malloc(sizeof (tok_arr[0]));
</li><li class="equal">    u_cmd - &gt; command = tok_arr[0];
</li><li class="equal">    u_cmd - &gt; args = malloc(sizeof ((tok_arr)));
</li><li class="equal">    u_cmd - &gt; args = tok_arr;
</li><li class="equal">    if (hist == NULL) {
</li><li class="equal">        hist = malloc(sizeof (history));
</li><li class="equal">    }
</li><li class="equal">    hist - &gt; prev_cmd = malloc(sizeof ( * u_cmd));
</li><li class="equal">    hist - &gt; prev_cmd = hist - &gt; cur_cmd;
</li><li class="equal">    hist - &gt; cur_cmd = malloc(sizeof ( * u_cmd));
</li><li class="equal">    hist - &gt; cur_cmd = u_cmd;
</li><li class="equal">}
</li><li class="equal">int is_redir_cmd(command * cmd, int ac) {
</li><li class="equal">    int rv = 0, i;
</li><li class="equal">    for (i = 0; i &lt; ac &amp;&amp; rv != 1; i++) {
</li><li class="equal">        rv = (is_redir_symbol( ** (cmd - &gt; args + i))) ? 1 : 0;
</li><li class="equal">    }
</li><li class="equal">    return rv;
</li><li class="equal">}
</li><li class="equal">int is_redir_symbol(char c) {
</li><li class="equal">    return c == REDIR_TO_PROG || c == STDOUT_TO_FILE || c == FILE_TO_STDOUT;
</li><li class="equal">}
</li><li class="equal">void exec_redir(command * cur_cmd, int ac) {
</li><li class="equal">    int i, arg_cnt;
</li><li class="equal">    int fd[2];
</li><li class="equal">    int save_in, save_out, output_fd = -1, input_fd = -1;
</li><li class="equal">    char * cur_tok, * next_tok;
</li><li class="equal">    char cur_tok_c;
</li><li class="equal">    char * orig_cmd_line = malloc(strlen(cur_cmd - &gt; cmd_line));
</li><li class="equal">    strcpy(orig_cmd_line, cur_cmd - &gt; cmd_line);
</li><li class="equal">    command * new_cmd = malloc(sizeof (command));
</li><li class="equal">    char ** tok_arr = malloc(sizeof (token_array));
</li><li class="equal">    for (i = 0; i &lt; ac; i++) {
</li><li class="equal">        cur_tok = *(token_array + i);
</li><li class="equal">        cur_tok_c = cur_tok[0];
</li><li class="equal">        if (is_redir_symbol(cur_tok_c)) {
</li><li class="equal">            next_tok = malloc(strlen( * (token_array + i + 1)));
</li><li class="equal">            next_tok = *(token_array + i + 1);
</li><li class="equal">            switch (cur_tok_c) {
</li><li class="equal">            case STDOUT_TO_FILE:
</li><li class="equal">                save_out = dup(STDOUT_FILENO);
</li><li class="equal">                char * file = next_tok;
</li><li class="equal">                arg_cnt = tokenize_input(cur_cmd - &gt; cmd_line, &amp; tok_arr, i - 1, REDIR_DELIM);
</li><li class="equal">                initialize_cmd(new_cmd, tok_arr);
</li><li class="equal">                output_fd = open(file, O_RDWR | O_CREAT, S_IRWXU | S_IRWXG | S_IRWXO);
</li><li class="equal">                if (output_fd &lt; 0) {
</li><li class="equal">                    puts("Error in accessing that file. Program will now exit.");
</li><li class="equal">                    break;
</li><li class="equal">                }
</li><li class="equal">                if (close(STDOUT_FILENO) &lt; 0) {
</li><li class="equal">                    puts("Error in closing stdout. Program will now exit.\n");
</li><li class="equal">                    break;
</li><li class="equal">                }
</li><li class="equal">                if (dup(output_fd) != STDOUT_FILENO) {
</li><li class="equal">                    puts("File descriptor is not equal to stdout. Program will now exit.\n");
</li><li class="equal">                    break;
</li><li class="equal">                }
</li><li class="equal">                close(output_fd);
</li><li class="equal">                execute_cmd(new_cmd, arg_cnt);
</li><li class="equal">                dup2(save_out, STDOUT_FILENO);
</li><li class="equal">                close(save_out);
</li><li class="equal">                strcpy(cur_cmd - &gt; cmd_line, orig_cmd_line);
</li><li class="equal">                break;
</li><li class="equal">            case FILE_TO_STDOUT:
</li><li class="equal">                save_in = dup(STDIN_FILENO);
</li><li class="equal">                file = next_tok;
</li><li class="equal">                arg_cnt = tokenize_input(cur_cmd - &gt; cmd_line, &amp; tok_arr, i - 1, REDIR_DELIM);
</li><li class="equal">                initialize_cmd(new_cmd, tok_arr);
</li><li class="equal">                input_fd = open(file, O_RDONLY, S_IRUSR | S_IWUSR);
</li><li class="equal">                if (input_fd &lt; 0) {
</li><li class="equal">                    puts("Error in accessing that file. Program will now exit.\n");
</li><li class="equal">                    break;
</li><li class="equal">                }
</li><li class="equal">                if (close(STDIN_FILENO) &lt; 0) {
</li><li class="equal">                    puts("Error in closing stdout. Program will now exit.\n");
</li><li class="equal">                    break;
</li><li class="equal">                }
</li><li class="equal">                if (dup(input_fd) != STDIN_FILENO) {
</li><li class="equal">                    puts("File descriptor is not equal to standard output. Program will now exit.\n");
</li><li class="equal">                    break;
</li><li class="equal">                }
</li><li class="equal">                close(input_fd);
</li><li class="equal">                execute_cmd(new_cmd, arg_cnt);
</li><li class="equal">                dup2(save_in, fileno(stdin));
</li><li class="equal">                close(save_in);
</li><li class="equal">                strcpy(cur_cmd - &gt; cmd_line, orig_cmd_line);
</li><li class="equal">                break;
</li><li class="equal">            case REDIR_TO_PROG:
</li><li class="equal">                arg_cnt = tokenize_input(cur_cmd - &gt; cmd_line, &amp; tok_arr, i - 1, REDIR_DELIM);
</li><li class="equal">                initialize_cmd(new_cmd, tok_arr);
</li><li class="equal">                pipe(fd);
</li><li class="equal">                execute_cmd(new_cmd, arg_cnt);
</li><li class="equal">                break;
</li><li class="equal">            }
</li><li class="equal">        }
</li><li class="equal">    }
</li><li class="equal">}
</li><li class="replace">int input_file(char * argv[], command * cur_cmd<em>)</em> <em></em>{
</li><li class="equal">    FILE * fp;
</li><li class="equal">    fp = fopen( * (argv + 1), "r");
</li><li class="equal">    if (fp != NULL) {
</li><li class="equal">        while (fgets(cmd, MAX_INPUT, fp) != NULL) {
</li><li class="replace">            arg_cnt = tokenize_input(cmd, <em>(char</em> <em>***) </em>tok<em>en</em>_arr<em>ay</em>, MAX_INPUT, DELIMITERS);
</li><li class="equal">            if (arg_cnt &lt; 1) {
</li><li class="equal">                continue;
</li><li class="equal">            }
</li><li class="equal">            initialize_cmd(cur_cmd, token_array);
</li><li class="equal">            execute_cmd(cur_cmd, arg_cnt);
</li><li class="equal">        }
</li><li class="equal">        fclose(fp);
</li><li class="equal">        return 0;
</li><li class="equal">    }
</li><li class="equal">    write(2, INVALID_FILE, strlen(INVALID_FILE));
</li><li class="equal">    return 1;
</li><li class="equal">}
</li><li class="equal">void print_tokens(char ** tok_arr) {
</li><li class="equal">    int i;
</li><li class="equal">    for (i = 0; *(tok_arr + i) != NULL; i++) {
</li><li class="equal">        printf("token:%s\n", * (tok_arr + i));
</li><li class="equal">    }
</li><li class="equal">}
</li><li class="equal">void execute_cmd(command * cmd, int ac) {
</li><li class="equal">    int status = 0;
</li><li class="equal">    pid_t wpid;
</li><li class="equal">    struct stat file_stat;
</li><li class="equal">    char * cmd_val = cmd - &gt; command;
</li><li class="equal">    char val;
</li><li class="equal">    char * ptr;
</li><li class="equal">    if (dflag) {
</li><li class="equal">        run(cmd - &gt; command);
</li><li class="equal">    }
</li><li class="replace">    if (<em>!bu</em>i<em>lt</em>_<em></em>i<em>n(</em>cmd<em></em>, ac)) {
</li><li class="replace">        <em></em>i<em>f </em>(<em>!str</em>cm<em>p(cm</em>d<em>_val</em>, <em>ECHO</em>)<em>) {</em>
</li><li class="replace">    <em></em> <em></em> <em></em> <em>     va</em>l<em></em>i<em></em>d<em>_v</em>a<em>r(</em>c<em>md</em> <em>- &gt; args, ac);</em>
</li><li class="replace">        <em>}</em>
</li><li class="replace">        <em>if</em> <em>(</em> <em>*</em> <em>(cmd</em> <em>- &gt; </em>a<em></em>r<em>gs[a</em>c<em></em> - <em>1])</em> <em>==</em> <em>'&amp;'</em>)<em> {</em>
</li><li class="insert">            cmd - &gt; args[ac - 1] = '\0';
</li><li class="equal">        }
</li><li class="equal">        cmd - &gt; pid = fork();
</li><li class="equal">        if (cmd - &gt; pid == -1) {
</li><li class="equal">            exit(1);
</li><li class="equal">        } else if (cmd - &gt; pid == 0) {
</li><li class="equal">            if (file_exists( &amp; cmd - &gt; command, file_stat)) {
</li><li class="equal">                printf("executing command\n");
</li><li class="equal">                execvp(cmd - &gt; command, cmd - &gt; args);
</li><li class="equal">                printf("%s: command not found\n", cmd - &gt; command);
</li><li class="equal">                exit(1);
</li><li class="equal">            } else {
</li><li class="equal">                puts("File not found\n");
</li><li class="equal">                exit(1);
</li><li class="equal">            }
</li><li class="equal">        } else {
</li><li class="equal">            do {
</li><li class="equal">                wpid = waitpid(cmd - &gt; pid, &amp; status, WCONTINUED | WUNTRACED);
</li><li class="equal">                val = WEXITSTATUS(status) + '0';
</li><li class="equal">                ptr = &amp;val;
</li><li class="equal">                setenv("?", ptr, 1);
</li><li class="equal">            } while (wpid &gt; 0);
</li><li class="equal">            if (dflag) 
</li><li class="equal">                end(cmd - &gt; command, WEXITSTATUS(status));
</li><li class="equal">        }
</li><li class="equal">    }
</li><li class="equal">}
</li><li class="equal">void valid_var(char ** args, int a) {
</li><li class="equal">    char * beg;
</li><li class="equal">    int i = 1;
</li><li class="equal">    for (i = 1; i &lt; a; i++) {
</li><li class="equal">        beg = memchr( * (args + i), '$', strlen( * (args + i)));
</li><li class="equal">        if (beg == NULL) 
</li><li class="equal">            continue;
</li><li class="equal">        else if (isalnumvar(beg)) { * (args + i) = getenv(++beg);
</li><li class="equal">        }
</li><li class="equal">    }
</li><li class="equal">}
</li><li class="equal">int built_in(command * cmd, int ac) {
</li><li class="equal">    char * cmd_val = cmd - &gt; command;
</li><li class="equal">    if (!strcmp(cmd_val, EXIT)) {
</li><li class="equal">        exit(1);
</li><li class="equal">    } else if (!strcmp(cmd_val, CH_DIR)) {
</li><li class="equal">        change_directory(cmd - &gt; args[PATH_LOC]);
</li><li class="equal">        return 1;
</li><li class="equal">    } else if (!strcmp(cmd_val, PRT_WRK_DIR)) {
</li><li class="equal">        print_working_dir();
</li><li class="equal">        return 1;
</li><li class="equal">    } else if (!strcmp(cmd_val, SET)) {
</li><li class="equal">        set_variable(cmd - &gt; args, ac);
</li><li class="equal">        return 1;
</li><li class="equal">    } else if (!strcmp(cmd_val, WOLFIE)) {
</li><li class="empty">​</li><li class="equal">        return 1;
</li><li class="equal">    } else if (!strcmp(cmd_val, BACKGROUND)) {
</li><li class="equal">        return 1;
</li><li class="equal">    } else if (!strcmp(cmd_val, FOREGROUND)) {
</li><li class="equal">        return 1;
</li><li class="insert">    } else if (is_redir_cmd(cmd, ac)) {
</li><li class="insert">        puts("going to redir\n");
</li><li class="insert">        exec_redir(cmd, ac);
</li><li class="equal">    } else if (!strcmp(cmd_val, JOBS)) {
</li><li class="equal">        return 1;
</li><li class="equal">    }
</li><li class="equal">    return 0;
</li><li class="equal">}
</li><li class="equal">int isalnumvar(char * str) {
</li><li class="equal">    int i = 1;
</li><li class="equal">    if (strlen(str) == 2 &amp;&amp; * (str + 1) == '?') 
</li><li class="equal">        return 1;
</li><li class="equal">    
</li><li class="equal">    for (i = 1; i &lt; strlen(str); i++) {
</li><li class="equal">        if (isalnum( * (str + i))) 
</li><li class="equal">            continue;
</li><li class="equal">        else {
</li><li class="equal">            return 0;
</li><li class="equal">        }
</li><li class="equal">    }
</li><li class="equal">    return 1;
</li><li class="equal">}
</li><li class="equal">int set_variable(char ** args, int count) {
</li><li class="equal">    if (count == 1 || count == 3 || count &gt; 4) {
</li><li class="equal">        return 1;
</li><li class="equal">    }
</li><li class="equal">    if (count == 4) {
</li><li class="equal">        if ( ** (args + 2) == '=') {
</li><li class="equal">            setenv( * (args + 1), * (args + 3), 1);
</li><li class="equal">            return 0;
</li><li class="equal">        } else {
</li><li class="equal">            return 1;
</li><li class="equal">        }
</li><li class="equal">    }
</li><li class="equal">    char * var = malloc(sizeof (char) * (strlen( * (args + 1))));
</li><li class="equal">    char * ret;
</li><li class="equal">    char * val = malloc(sizeof (char) * strlen( * (args + 1)));;
</li><li class="equal">    char eq = '=';
</li><li class="equal">    if (count == 2) {
</li><li class="equal">        ret = memchr( * (args + 1), eq, strlen( * (args + 1)));
</li><li class="equal">        memcpy(var, * (args + 1), ret - * (args + 1));
</li><li class="equal">        ret++;
</li><li class="equal">        memcpy(val, ret, strlen(ret));
</li><li class="equal">        setenv(var, val, 1);
</li><li class="equal">    }
</li><li class="equal">    free(var);
</li><li class="equal">    free(val);
</li><li class="equal">    return 0;
</li><li class="equal">}
</li><li class="equal">void change_directory(char * path) {
</li><li class="equal">    if (!path) {
</li><li class="equal">        chdir(getenv(HOME_ENV));
</li><li class="equal">    } else if (chdir(path) != 0) {
</li><li class="equal">        printf("Failed to find %s\n", path);
</li><li class="equal">    }
</li><li class="equal">}
</li><li class="equal">char * get_cur_wrk_dir() {
</li><li class="equal">    return getcwd(NULL, MAX_PATH_LENGTH);
</li><li class="equal">}
</li><li class="equal">void print_working_dir() {
</li><li class="equal">    char * dir_path = get_cur_wrk_dir();
</li><li class="equal">    write(STDOUT, dir_path, strlen(dir_path));
</li><li class="equal">    write(STDOUT, "\n", 1);
</li><li class="equal">}
</li><li class="equal">int file_exists(char ** file_path, struct stat file_stat) {
</li><li class="equal">    char * orig_file_path;
</li><li class="equal">    char * concat_file_path;
</li><li class="equal">    orig_file_path = malloc(strlen( * file_path) + 2);
</li><li class="equal">    if ( ** file_path != '/') {
</li><li class="equal">        mystrcat(orig_file_path, "/");
</li><li class="equal">    }
</li><li class="equal">    mystrcat(orig_file_path, * file_path);
</li><li class="equal">    int ret_val = 0;
</li><li class="equal">    char * cur_path;
</li><li class="equal">    char * all_paths = getenv(PATH_ENV);
</li><li class="equal">    cur_path = strtok(all_paths, PATH_DELIM);
</li><li class="equal">    while (cur_path != NULL) {
</li><li class="equal">        concat_file_path = malloc(strlen(orig_file_path) + strlen(cur_path) + 1);
</li><li class="equal">        mystrcat(concat_file_path, cur_path);
</li><li class="equal">        mystrcat(concat_file_path, orig_file_path);
</li><li class="equal">        if ((ret_val = !stat(concat_file_path, &amp; file_stat))) { * file_path = concat_file_path;
</li><li class="equal">            break;
</li><li class="equal">        }
</li><li class="equal">        cur_path = strtok(NULL, PATH_DELIM);
</li><li class="equal">    }
</li><li class="equal">    return ret_val;
</li><li class="equal">}
</li></ol></div><p class="author">Diff view written by <a href="http://prettydiff.com/">Pretty Diff</a>.</p></div><script type='application/javascript'><![CDATA[var pd={};pd.colSliderProperties=[];(function(){var d=document.getElementsByTagName('ol'),cells=d[0].getElemensByTagName('li'),len=cells.length,a=0;pd.colSliderProperties=[d[0].clientWidth,d[1].clientWidth,d[2].parentNode.clientWidth,d[2].parentNode.parentNode.clientWidth,d[2].parentNode.offsetLeft-d[2].parentNode.parentNode.offsetLeft,];for(a=0;a<len;a+=1){if(cells[a].getAttribute('class')==='fold'){cells[a].onmousedown=pd.difffold;}}if(d.length>3){d[2].onmousedown=pd.colSliderGrab;d[2].ontouchstart=pd.colSliderGrab;}}());pd.difffold=function dom__difffold(){var a=0,b=0,self=this,title=self.getAttribute('title').split('line '),min=Number(title[1].substr(0,title[1].indexOf(' '))),max=Number(title[2]),inner=self.innerHTML,lists=[],parent=self.parentNode.parentNode,listnodes=(parent.getAttribute('class')==='diff')?parent.getElementsByTagName('ol'):parent.parentNode.getElementsByTagName('ol'),listLen=listnodes.length;for(a=0;a<listLen;a+=1){lists.push(listnodes[a].getElementsByTagName('li'));}for(a=0;a<min;a+=1){if(lists[0][a].getAttribute('class')==='empty'){min+=1;max+=1;}}max=(max>=lists[0].length)?lists[0].length:max;if(inner.charAt(0)==='-'){self.innerHTML='+'+inner.substr(1);for(a=min;a<max;a+=1){for(b=0;b<listLen;b+=1){lists[b][a].style.display='none';}}}else{self.innerHTML='-'+inner.substr(1);for(a=min;a<max;a+=1){for(b=0;b<listLen;b+=1){lists[b][a].style.display='block';}}}};pd.colSliderGrab=function dom__colSliderGrab(e){var event=e||window.event,touch=(e!==null&&e.type==='touchstart')?true:false,node=this,diffRight=node.parentNode,diff=diffRight.parentNode,subOffset=0,counter=pd.colSliderProperties[0],data=pd.colSliderProperties[1],width=pd.colSliderProperties[2],total=pd.colSliderProperties[3],offset=pd.colSliderProperties[4],min=0,max=data-1,status='ew',minAdjust=min+15,maxAdjust=max-15,withinRange=false,diffLeft=diffRight.previousSibling,drop=function dom__colSliderGrab_drop(f){f=f||window.event;f.preventDefault();node.style.cursor=status+'-resize';if(touch===true){document.ontouchmove=null;document.ontouchend=null;}else{document.onmousemove=null;document.onmouseup=null;}},boxmove=function dom__colSliderGrab_boxmove(f){f=f||window.event;f.preventDefault();if(touch===true){subOffset=offset-f.touches[0].clientX;}else{subOffset=offset-f.clientX;}if(subOffset>minAdjust&&subOffset<maxAdjust){withinRange=true;}if(withinRange===true&&subOffset>maxAdjust){diffRight.style.width=((total-counter-2)/10)+'em';status='e';}else if(withinRange===true&&subOffset<minAdjust){diffRight.style.width=(width/10)+'em';status='w';}else if(subOffset<max&&subOffset>min){diffRight.style.width=((width+subOffset)/10)+'em';status='ew';}if(touch===true){document.ontouchend=drop;}else{document.onmouseup=drop;}};event.preventDefault();if(typeof pd.o==='object'&&pd.o.report.code.box!==null){offset+=pd.o.report.code.box.offsetLeft;offset-=pd.o.report.code.body.scrollLeft;}else{subOffset=(document.body.parentNode.scrollLeft>document.body.scrollLeft)?document.body.parentNode.scrollLeft:document.body.scrollLeft;offset-=subOffset;}offset+=node.clientWidth;node.style.cursor='ew-resize';diff.style.width=(total/10)+'em';diff.style.display='inline-block';if(diffLeft.nodeType!==1){do{diffLeft=diffLeft.previousSibling;}while(diffLeft.nodeType!==1);}diffLeft.style.display='block';diffRight.style.width=(diffRight.clientWidth/10)+'em';diffRight.style.position='absolute';if(touch===true){document.ontouchmove=boxmove;document.ontouchstart=false;}else{document.onmousemove=boxmove;document.onmousedown=null;}};]]></script></div></body></html>